name: Turbo

on:
  pull_request:
  push:
    branches:
      - main
  merge_group:

concurrency:
  group: ${{ github.event_name == 'pull_request' && format('pr-{0}', github.event.pull_request.number) || (github.event_name == 'merge_group' && format('merge-queue-{0}', github.run_id) || 'staging') }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Prepare: detect changes and set job-ref identifier
  prepare:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    outputs:
      job-ref: ${{ steps.set-job-ref.outputs.job-ref }}
      web-preview-url: ${{ steps.preview-urls.outputs.web-url }}
      platform-preview-url: ${{ steps.preview-urls.outputs.platform-url }}
      web-changed: ${{ steps.detect.outputs.web-changed }}
      docs-changed: ${{ steps.detect.outputs.docs-changed }}
      cli-changed: ${{ steps.detect.outputs.cli-changed }}
      runner-changed: ${{ steps.detect.outputs.runner-changed }}
      platform-changed: ${{ steps.detect.outputs.platform-changed }}
      e2b-changed: ${{ steps.detect-e2b.outputs.e2b-changed }}
      sandbox-changed: ${{ steps.detect-docker.outputs.sandbox-changed }}
      docker-web-changed: ${{ steps.detect-docker.outputs.docker-web-changed }}
      docker-platform-changed: ${{ steps.detect-docker.outputs.docker-platform-changed }}
      migration-changed: ${{ steps.detect-migration.outputs.migration-changed }}
      crates-changed: ${{ steps.detect-crates.outputs.crates-changed }}
      cli-e2e-parallel-matrix: ${{ steps.cli-e2e-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git safe directory
        run: git config --global --add safe.directory /__w/vm0/vm0

      - name: Detect changes
        id: detect
        run: |
          echo "Checking for changes..."

          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
            echo "PR mode: comparing against merge base $BASE_REF"
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
            echo "Merge queue mode: comparing against base $BASE_REF"
          else
            BASE_REF="HEAD^"
            echo "Main push mode: comparing against HEAD^"
          fi

          # Run changed.sh to get all package changes in one go
          CHANGES_JSON=$(./scripts/changed.sh $BASE_REF)

          # Parse JSON and set outputs for each app
          for app in $(ls turbo/apps); do
            # Get the package name from package.json
            if [ -f "turbo/apps/$app/package.json" ]; then
              PKG_NAME=$(jq -r '.name' "turbo/apps/$app/package.json")
              CHANGED=$(echo "$CHANGES_JSON" | jq -r ".\"$PKG_NAME\" // false")

              if [ "$CHANGED" = "true" ]; then
                echo "Changes detected in $app ($PKG_NAME)"
                echo "${app}-changed=true" >> $GITHUB_OUTPUT
              else
                echo "No changes in $app ($PKG_NAME)"
                echo "${app}-changed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "No package.json for $app, skipping"
              echo "${app}-changed=false" >> $GITHUB_OUTPUT
            fi
          done

      - name: Detect E2B template changes
        id: detect-e2b
        run: |
          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
          else
            BASE_REF="HEAD^"
          fi

          # Check if E2B template files changed
          if git diff --name-only "$BASE_REF" HEAD | grep -q "^turbo/scripts/e2b/"; then
            echo "E2B template changes detected"
            echo "e2b-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No E2B template changes"
            echo "e2b-changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect Docker file changes
        id: detect-docker
        run: |
          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
          else
            BASE_REF="HEAD^"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE_REF" HEAD)

          # Check if web Docker files changed
          if echo "$CHANGED_FILES" | grep -qE "^docker/(Dockerfile\.web|entrypoint\.sh)$"; then
            echo "Docker web file changes detected"
            echo "docker-web-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No Docker web file changes"
            echo "docker-web-changed=false" >> $GITHUB_OUTPUT
          fi

          # Check if platform Docker files changed
          if echo "$CHANGED_FILES" | grep -qE "^docker/(Dockerfile\.platform|Caddyfile\.platform)$"; then
            echo "Docker platform file changes detected"
            echo "docker-platform-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No Docker platform file changes"
            echo "docker-platform-changed=false" >> $GITHUB_OUTPUT
          fi

          # Check if sandbox Docker file changed
          if echo "$CHANGED_FILES" | grep -q "^docker/Dockerfile\.sandbox$"; then
            echo "Docker sandbox file changes detected"
            echo "sandbox-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No Docker sandbox file changes"
            echo "sandbox-changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect migration/schema changes
        id: detect-migration
        run: |
          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
          else
            BASE_REF="HEAD^"
          fi

          # Check if migration or schema files changed
          if git diff --name-only "$BASE_REF" HEAD | grep -qE "^turbo/apps/web/src/db/(migrations|schema)/"; then
            echo "Migration or schema changes detected"
            echo "migration-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No migration or schema changes"
            echo "migration-changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect crates changes
        id: detect-crates
        run: |
          # Determine base ref based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            BASE_REF="${{ github.event.merge_group.base_sha }}"
          else
            BASE_REF="HEAD^"
          fi

          if git diff --name-only "$BASE_REF" HEAD | grep -q "^crates/"; then
            echo "Crates changes detected"
            echo "crates-changed=true" >> $GITHUB_OUTPUT
          else
            echo "No crates changes"
            echo "crates-changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Set job-ref
        id: set-job-ref
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "job-ref=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "Job ref set to: pr-${{ github.event.pull_request.number }}"
          elif [ "${{ github.event_name }}" = "merge_group" ]; then
            echo "job-ref=" >> $GITHUB_OUTPUT
            echo "Job ref set to: (empty - merge_group will skip deployments)"
          else
            echo "job-ref=staging" >> $GITHUB_OUTPUT
            echo "Job ref set to: staging"
          fi

      - name: Set preview URLs
        id: preview-urls
        run: |
          JOB_REF="${{ steps.set-job-ref.outputs.job-ref }}"
          PREVIEW_DOMAIN="${{ vars.PREVIEW_DOMAIN }}"

          if [ -n "$PREVIEW_DOMAIN" ] && [ -n "$JOB_REF" ]; then
            echo "web-url=https://${JOB_REF}-www.${PREVIEW_DOMAIN}" >> $GITHUB_OUTPUT
            echo "platform-url=https://${JOB_REF}-platform.${PREVIEW_DOMAIN}" >> $GITHUB_OUTPUT
            echo "Preview URL set to: https://${JOB_REF}-www.${PREVIEW_DOMAIN}"
          else
            echo "web-url=" >> $GITHUB_OUTPUT
            echo "platform-url=" >> $GITHUB_OUTPUT
            echo "Preview URL not set (PREVIEW_DOMAIN or job-ref is empty)"
          fi

      - name: Generate CLI E2E parallel test matrix
        id: cli-e2e-matrix
        shell: bash
        run: |
          # Scan test files and distribute them across chunks using load balancing
          # Dynamic chunk count: ~15 tests per chunk, max 10 chunks
          TESTS_PER_CHUNK=15
          MAX_CHUNKS=10

          # Count tests per file
          declare -A FILE_TESTS
          TOTAL_TESTS=0
          for f in e2e/tests/02-parallel/*.bats; do
            count=$(grep -c "^@test" "$f" 2>/dev/null || echo 0)
            FILE_TESTS["$f"]=$count
            TOTAL_TESTS=$((TOTAL_TESTS + count))
          done

          # Calculate number of chunks (min 1, max MAX_CHUNKS)
          NUM_CHUNKS=$(( (TOTAL_TESTS + TESTS_PER_CHUNK - 1) / TESTS_PER_CHUNK ))
          NUM_CHUNKS=$(( NUM_CHUNKS < 1 ? 1 : NUM_CHUNKS ))
          NUM_CHUNKS=$(( NUM_CHUNKS > MAX_CHUNKS ? MAX_CHUNKS : NUM_CHUNKS ))

          # Sort files by test count descending for better distribution
          mapfile -t SORTED_FILES < <(
            for f in "${!FILE_TESTS[@]}"; do
              echo "${FILE_TESTS[$f]} $f"
            done | sort -rn | cut -d' ' -f2
          )

          echo "Found ${#SORTED_FILES[@]} files with $TOTAL_TESTS total tests"
          echo "Creating $NUM_CHUNKS chunks (~$TESTS_PER_CHUNK tests each)"

          # Initialize chunk arrays and test counts
          declare -a CHUNK_FILES
          declare -a CHUNK_COUNTS
          for ((i=0; i<NUM_CHUNKS; i++)); do
            CHUNK_FILES[$i]=""
            CHUNK_COUNTS[$i]=0
          done

          # Distribute files using greedy load balancing (assign to least loaded chunk)
          for f in "${SORTED_FILES[@]}"; do
            tests=${FILE_TESTS[$f]}

            # Find chunk with minimum tests
            min_chunk=0
            min_count=${CHUNK_COUNTS[0]}
            for ((i=1; i<NUM_CHUNKS; i++)); do
              if [ ${CHUNK_COUNTS[$i]} -lt $min_count ]; then
                min_chunk=$i
                min_count=${CHUNK_COUNTS[$i]}
              fi
            done

            # Add file to that chunk
            if [ -n "${CHUNK_FILES[$min_chunk]}" ]; then
              CHUNK_FILES[$min_chunk]="${CHUNK_FILES[$min_chunk]} $f"
            else
              CHUNK_FILES[$min_chunk]="$f"
            fi
            CHUNK_COUNTS[$min_chunk]=$((CHUNK_COUNTS[$min_chunk] + tests))
          done

          # Build JSON array
          CHUNKS="["
          for ((i=0; i<NUM_CHUNKS; i++)); do
            if [ $i -gt 0 ]; then
              CHUNKS="$CHUNKS,"
            fi
            files="${CHUNK_FILES[$i]}"
            file_count=$(echo $files | wc -w)
            CHUNKS="$CHUNKS{\"index\":$((i+1)),\"files\":\"$files\"}"
            echo "Chunk $((i+1)): $file_count files, ${CHUNK_COUNTS[$i]} tests"
          done
          CHUNKS="$CHUNKS]"

          echo "matrix=$CHUNKS" >> $GITHUB_OUTPUT

  file-size-check:
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check file sizes
        run: |
          # Get changed files in PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA=${{ github.event.pull_request.base.sha }}
          else
            BASE_SHA="HEAD^"
          fi

          # Get list of added/modified files (exclude deleted)
          CHANGED_FILES=$(git diff --name-only --diff-filter=AM "$BASE_SHA" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No files changed"
            exit 0
          fi

          # Filter out whitelisted files
          FILTERED_FILES=$(echo "$CHANGED_FILES" | grep -v -E '^turbo/apps/web/public/(og-image\.png|assets/(cta-ellipse\.png|code_illustration\.svg))$' || true)

          if [ -z "$FILTERED_FILES" ]; then
            echo "All changed files are whitelisted"
            exit 0
          fi

          # Check file sizes
          ./scripts/check-file-size.sh $FILTERED_FILES

  # Lint jobs - split into 4 parallel jobs for faster CI
  lint-eslint:
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Lint
        working-directory: turbo
        run: pnpm lint

  lint-types:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Type Check
        working-directory: turbo
        run: pnpm check-types

  lint-format:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Prettier
        working-directory: turbo
        run: pnpm prettier --check .

  lint-knip:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Knip
        working-directory: turbo
        run: pnpm knip

  # Test jobs - split into 4 parallel jobs by project
  test-web:
    needs: prepare
    runs-on: ubuntu-latest
    # Skip for release-please commits (only version bumps and changelogs)
    if: "${{ github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release') }}"
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    services:
      postgres:
        image: postgres:17-alpine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        env:
          POSTGRES_HOST_AUTH_METHOD: trust
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Run Database Migrations
        working-directory: turbo
        env:
          DATABASE_URL: postgresql://postgres@postgres:5432/postgres
        run: pnpm --filter web db:migrate
      - name: Test Web
        working-directory: turbo
        env:
          DATABASE_URL: postgresql://postgres@postgres:5432/postgres
        run: pnpm vitest run --project=web

  test-migrate:
    needs: prepare
    runs-on: ubuntu-latest
    # Only run when migration or schema files changed
    if: needs.prepare.outputs.migration-changed == 'true'
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    services:
      postgres:
        image: postgres:17-alpine
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        env:
          POSTGRES_HOST_AUTH_METHOD: trust
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Test Migration Consistency
        working-directory: turbo/apps/web
        env:
          DATABASE_URL: postgresql://postgres@postgres:5432/postgres
        run: pnpm tsx scripts/test-migration-consistency-schema.ts

  test-cli:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Test CLI
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/cli

  test-platform:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Test Platform
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/platform

  test-other:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init
      - name: Build Sandbox Scripts
        working-directory: turbo
        run: pnpm turbo run build --filter=@vm0/sandbox-scripts
      - name: Build vsock-guest example (for runner tests)
        run: cargo build --manifest-path crates/Cargo.toml -p vsock-guest --example vsock-guest
      - name: Test Other Packages
        working-directory: turbo
        run: pnpm vitest run --project=@vm0/runner --project=@vm0/core --project=@vm0/ui

  # Deploy web application with database
  deploy-web:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and web, CLI, runner, or platform changed
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.platform-changed == 'true' ||
        needs.prepare.outputs.crates-changed == 'true'
      )
    outputs:
      preview-url: ${{ steps.alias.outputs.url || steps.deploy.outputs.url }}
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      # Step 1: Create Neon database branch
      - name: Create Neon Branch and Run Migrations
        id: branch
        uses: ./.github/actions/neon-branch
        with:
          neon-api-key: ${{ secrets.NEON_API_KEY }}
          neon-project-id: ${{ vars.NEON_PROJECT_ID }}
          branch-name: "${{ needs.prepare.outputs.job-ref }}"
          action: "create"

      # Step 2: Deploy to Vercel with database URL
      - name: Deploy Web to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_WEB }}
          environment: preview
          deployment-env: web
          prebuilt: "true"
          environment-variables: |
            DATABASE_URL=${{ steps.branch.outputs.database-url }}
            BLOG_BASE_URL=${{ needs.prepare.outputs.web-preview-url }}
            CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            CLERK_SECRET_KEY=${{ secrets.CLERK_SECRET_KEY }}
            E2B_API_KEY=${{ secrets.E2B_API_KEY }}
            R2_ACCOUNT_ID=${{ vars.R2_ACCOUNT_ID }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            R2_USER_STORAGES_BUCKET_NAME=${{ vars.R2_USER_STORAGES_BUCKET_NAME }}
            SECRETS_ENCRYPTION_KEY=${{ secrets.SECRETS_ENCRYPTION_KEY }}
            OFFICIAL_RUNNER_SECRET=${{ secrets.OFFICIAL_RUNNER_SECRET }}
            AXIOM_TOKEN_SESSIONS=${{ secrets.AXIOM_TOKEN_SESSIONS }}
            AXIOM_TOKEN_TELEMETRY=${{ secrets.AXIOM_TOKEN_TELEMETRY }}
            AXIOM_DATASET_SUFFIX=dev
            USE_MOCK_CLAUDE=true
            CRON_SECRET=${{ secrets.CRON_SECRET }}
            ABLY_API_KEY=${{ secrets.ABLY_API_KEY }}
            CONCURRENT_RUN_LIMIT=0
            VM0_DEBUG=*
            CLAUDE_CODE_VERSION_URL=${{ vars.CLAUDE_CODE_VERSION_URL }}
            SLACK_CLIENT_ID=${{ vars.SLACK_CLIENT_ID }}
            SLACK_CLIENT_SECRET=${{ secrets.SLACK_CLIENT_SECRET }}
            SLACK_SIGNING_SECRET=${{ secrets.SLACK_SIGNING_SECRET }}
            SLACK_REDIRECT_BASE_URL=${{ needs.prepare.outputs.web-preview-url }}
            SLACK_DEFAULT_AGENT=${{ vars.SLACK_DEFAULT_AGENT }}
            SENTRY_DSN_WEB=${{ secrets.SENTRY_DSN_WEB }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_WEB }}
            GH_OAUTH_CLIENT_ID=${{ vars.GH_OAUTH_CLIENT_ID }}
            GH_OAUTH_CLIENT_SECRET=${{ secrets.GH_OAUTH_CLIENT_SECRET }}
            NOTION_OAUTH_CLIENT_ID=${{ vars.NOTION_OAUTH_CLIENT_ID }}
            NOTION_OAUTH_CLIENT_SECRET=${{ secrets.NOTION_OAUTH_CLIENT_SECRET }}
            NGROK_API_KEY=${{ secrets.NGROK_API_KEY }}
            NGROK_COMPUTER_CONNECTOR_DOMAIN=${{ vars.NGROK_COMPUTER_CONNECTOR_DOMAIN }}
            PLATFORM_URL=${{ needs.prepare.outputs.platform-preview-url }}
            RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
            RESEND_WEBHOOK_SECRET=${{ secrets.RESEND_WEBHOOK_SECRET }}
            RESEND_FROM_DOMAIN=${{ vars.RESEND_FROM_DOMAIN }}
            STRAPI_URL=${{ vars.STRAPI_URL }}
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      # Step 3: Create stable preview URL alias (when PREVIEW_DOMAIN is configured)
      - name: Create Vercel Alias
        id: alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: www
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

      # Step 4: Generate test token for E2E tests (runs in parallel with e2e-auth)
      - name: Generate E2E test token
        run: e2e/scripts/generate-test-token.sh
        env:
          VM0_API_URL: ${{ steps.alias.outputs.url || steps.deploy.outputs.url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Save test token to cache
        uses: actions/cache/save@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}

  # Deploy docs application
  deploy-docs:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and docs changed
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.docs-changed == 'true' }}"
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Docs to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_DOCS }}
          environment: preview
          deployment-env: docs
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      - name: Create Vercel Alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: docs
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

  # Deploy platform (Vite SPA)
  deploy-platform:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Deploy if job-ref is set (PR or main), not a release-please commit, and platform changed
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.platform-changed == 'true' }}"
    permissions:
      contents: read
      pull-requests: write
      deployments: write
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Deploy Platform to Vercel
        id: deploy
        uses: ./.github/actions/vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ vars.VERCEL_PROJECT_ID_PLATFORM }}
          environment: preview
          deployment-env: platform
          environment-variables: |
            VITE_CLERK_PUBLISHABLE_KEY=${{ vars.CLERK_PUBLISHABLE_KEY }}
            VITE_API_URL=${{ needs.prepare.outputs.web-preview-url }}
            VITE_SENTRY_DSN=${{ secrets.SENTRY_DSN_PLATFORM }}
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SENTRY_ORG=${{ vars.SENTRY_ORG }}
            SENTRY_PROJECT=${{ vars.SENTRY_PROJECT_PLATFORM }}
          meta-branch: ${{ github.head_ref || github.ref_name }}
          meta-pr: ${{ needs.prepare.outputs.job-ref }}
          skip-finish: ${{ github.event_name == 'pull_request' && vars.PREVIEW_DOMAIN != '' }}

      - name: Create Vercel Alias
        if: vars.PREVIEW_DOMAIN != ''
        uses: ./.github/actions/vercel-alias
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ vars.VERCEL_TEAM_ID }}
          deployment-url: ${{ steps.deploy.outputs.url }}
          app-name: platform
          job-ref: ${{ needs.prepare.outputs.job-ref }}
          preview-domain: ${{ vars.PREVIEW_DOMAIN }}
          deployment-id: ${{ steps.deploy.outputs.deployment-id }}
          deployment-env: ${{ steps.deploy.outputs.deployment-env }}

  # Verify device flow authentication works end-to-end (uses Playwright)
  # This job runs in parallel with E2E tests - it does NOT block them
  # E2E tests use the token generated by deploy-web instead
  e2e-auth:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-web]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Sandbox Scripts
        run: cd turbo && pnpm turbo run build --filter=@vm0/sandbox-scripts

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install E2E dependencies
        run: cd e2e && npm install

      - name: Install Playwright system dependencies
        run: npx playwright install-deps chromium

      - name: Install Playwright browsers
        run: cd e2e && npx playwright install chromium

      - name: Verify device flow authentication
        run: |
          echo "Verifying device flow with ${{ needs.deploy-web.outputs.preview-url }}"
          cd e2e && npm run auth
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CLERK_PUBLISHABLE_KEY: ${{ vars.CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  # Run API E2E tests (lightweight, fast)
  api-e2e-test:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, deploy-web]
    if: "${{ (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) && needs.prepare.outputs.job-ref != '' && needs.prepare.outputs.web-changed == 'true' }}"
    timeout-minutes: 5
    permissions:
      actions: read # Required to query cache API
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive # For BATS test framework

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Run API E2E Tests
        run: |
          echo "=== Running API E2E Tests ==="
          ./e2e/test/libs/bats/bin/bats -T ./e2e/tests/api/*.bats
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  # Run CLI E2E tests - Phase 1: Serial tests (establishes e2e-stable scope)
  cli-e2e-01-serial:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs:
      [
        prepare,
        deploy-web,
        lint-eslint,
        lint-types,
        lint-format,
        lint-knip,
        test-web,
        test-cli,
        test-platform,
        test-other,
      ]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.crates-changed == 'true'
      )
    timeout-minutes: 5
    permissions:
      actions: read # Required to query cache API
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Sandbox Scripts
        run: cd turbo && pnpm turbo run build --filter=@vm0/sandbox-scripts

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Serial E2E Tests
        run: |
          echo "=== Running Serial E2E Tests ==="
          BATS_TEST_TIMEOUT=30 ./e2e/test/libs/bats/bin/bats -T ./e2e/tests/01-serial/*.bats
          echo "✅ Serial tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Run CLI E2E tests - Phase 2: Parallel tests (does NOT need runner)
  # Uses dynamic matrix to split test files into chunks for parallel execution
  cli-e2e-02-parallel:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare, cli-e2e-01-serial, deploy-web]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true'
      )
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.prepare.outputs.cli-e2e-parallel-matrix) }}
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Sandbox Scripts
        run: cd turbo && pnpm turbo run build --filter=@vm0/sandbox-scripts

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install GNU parallel for bats
        run: apt-get update && apt-get install -y parallel

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Parallel E2E Tests (Chunk ${{ matrix.index }})
        run: |
          echo "=== Running Parallel E2E Tests (Chunk ${{ matrix.index }}) ==="
          echo "Files: ${{ matrix.files }}"
          BATS_TEST_TIMEOUT=60 ./e2e/test/libs/bats/bin/bats -T -j 5 --no-parallelize-within-files ${{ matrix.files }}
          echo "✅ Chunk ${{ matrix.index }} tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"
          ANTHROPIC_API_KEY: ${{ secrets.CI_ANTHROPIC_API_KEY }}

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Deploy runner prepare: cross-compile, deploy to all metal hosts, build rootfs/snapshot with mock URL
  # Runs in parallel with deploy-web since rootfs/snapshot don't need the preview URL
  # Skip on push to main - runner deployment is only needed for PRs
  deploy-runner-prepare:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain-rust:20260203
    needs: [prepare]
    timeout-minutes: 5
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.crates-changed == 'true'
      )
    outputs:
      host-count: ${{ steps.host.outputs.host-count }}
      bin-dir: ${{ steps.host.outputs.bin-dir }}
      runner-dir: ${{ steps.host.outputs.runner-dir }}
    steps:
      - uses: actions/checkout@v6

      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: crates -> target
          key: aarch64-musl

      - name: Cross-compile runner and guest binaries for ARM64
        run: |
          cd crates
          cargo build --release --target aarch64-unknown-linux-musl \
            -p runner -p guest-init -p guest-download -p guest-agent -p guest-mock-claude

      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"

      - name: Resolve metal hosts
        id: host
        env:
          METAL_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
        run: |
          echo "bin-dir=~/.vm0-runner/bin/${JOB_REF}" >> "$GITHUB_OUTPUT"
          echo "runner-dir=~/.vm0-runner/runners/${JOB_REF}" >> "$GITHUB_OUTPUT"
          NUM_HOSTS=$(echo "$METAL_HOSTS" | tr ',' '\n' | grep -c .)
          if [ "$NUM_HOSTS" -lt 1 ]; then
            echo "::error::AWS_METAL_RUNNER_HOSTS is empty"
            exit 1
          fi
          echo "host-count=${NUM_HOSTS}" >> "$GITHUB_OUTPUT"
          echo "Deploying to ${NUM_HOSTS} metal hosts"

      - name: Deploy binaries and build rootfs/snapshot on all metal hosts
        shell: bash
        env:
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
          METAL_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          BIN_DIR: ${{ steps.host.outputs.bin-dir }}
          RUNNER_DIR: ${{ steps.host.outputs.runner-dir }}
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $HOME/.ssh/runner.pem"
          TARGET_DIR="crates/target/aarch64-unknown-linux-musl/release"

          deploy_to_host() {
            local HOST=$1
            local REMOTE="${METAL_USER}@${HOST}"
            echo "=== Deploying to ${HOST} ==="

            # Clean previous run artifacts and upload binaries
            ssh $SSH_OPTS $REMOTE "rm -rf ${BIN_DIR} ${RUNNER_DIR} && mkdir -p ${BIN_DIR}"
            for bin in runner guest-init guest-download guest-agent guest-mock-claude; do
              scp $SSH_OPTS "${TARGET_DIR}/${bin}" "${REMOTE}:${BIN_DIR}/"
            done

            # Run setup (downloads firecracker/kernel/mitmdump, cached + idempotent)
            ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner setup"

            # Run build with mock URL to trigger rootfs+snapshot construction and caching
            # --api-url does not affect rootfs/snapshot hash, only runner.yaml config
            ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner build \
              --name ${JOB_REF} \
              --group vm0/development-${JOB_REF} \
              --runner-dirname ${JOB_REF} \
              --guest-init ${BIN_DIR}/guest-init \
              --guest-download ${BIN_DIR}/guest-download \
              --guest-agent ${BIN_DIR}/guest-agent \
              --guest-mock-claude ${BIN_DIR}/guest-mock-claude \
              --api-url http://localhost \
              --token vm0_official_${OFFICIAL_RUNNER_SECRET}"

            # Clean up old rootfs/snapshots, keep the 3 most recent
            ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner gc --keep-latest 3"
            echo "=== Done deploying to ${HOST} ==="
          }

          LOG_DIR=$(mktemp -d)
          HOSTS=()
          PIDS=()
          for HOST in $(echo "$METAL_HOSTS" | tr ',' ' '); do
            deploy_to_host "$HOST" > "${LOG_DIR}/${HOST}.log" 2>&1 &
            PIDS+=($!)
            HOSTS+=("$HOST")
          done

          FAILED=0
          for i in "${!PIDS[@]}"; do
            if ! wait "${PIDS[$i]}"; then
              FAILED=1
              echo "::error::Deployment failed on ${HOSTS[$i]}"
            fi
            echo "=== ${HOSTS[$i]} ==="
            cat "${LOG_DIR}/${HOSTS[$i]}.log"
          done
          rm -rf "$LOG_DIR"
          if [ "$FAILED" -ne 0 ]; then
            exit 1
          fi

  # Deploy runner start: rebuild config with real preview URL and start service
  # Waits for both deploy-runner-prepare (binaries + rootfs/snapshot) and deploy-web (preview URL)
  # The second `runner build` is a cache hit — only rewrites runner.yaml (~100ms)
  deploy-runner-start:
    runs-on: ubuntu-latest
    needs: [prepare, deploy-runner-prepare, deploy-web]
    timeout-minutes: 2
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.crates-changed == 'true'
      )
    steps:
      - name: Setup SSH
        env:
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"

      # Read METAL_HOSTS from secret directly — GitHub Actions masks secret values in job outputs
      - name: Rebuild config and start runner service on all hosts
        env:
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
          METAL_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          BIN_DIR: ${{ needs.deploy-runner-prepare.outputs.bin-dir }}
          RUNNER_DIR: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
          PREVIEW_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_BYPASS: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $HOME/.ssh/runner.pem"

          start_on_host() {
            local HOST=$1
            local REMOTE="${METAL_USER}@${HOST}"
            echo "=== Starting runner on ${HOST} ==="

            # Re-run build with real preview URL (cache hit, only rewrites runner.yaml)
            ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner build \
              --name ${JOB_REF} \
              --group vm0/development-${JOB_REF} \
              --runner-dirname ${JOB_REF} \
              --guest-init ${BIN_DIR}/guest-init \
              --guest-download ${BIN_DIR}/guest-download \
              --guest-agent ${BIN_DIR}/guest-agent \
              --guest-mock-claude ${BIN_DIR}/guest-mock-claude \
              --api-url ${PREVIEW_URL} \
              --token vm0_official_${OFFICIAL_RUNNER_SECRET}"

            # Start as systemd transient service
            ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner service start \
              --name ${JOB_REF} \
              --config ${RUNNER_DIR}/runner.yaml \
              --env VERCEL_AUTOMATION_BYPASS_SECRET=${VERCEL_BYPASS} \
              --env USE_MOCK_CLAUDE=true"
            echo "=== Runner started on ${HOST} ==="
          }

          LOG_DIR=$(mktemp -d)
          HOSTS=()
          PIDS=()
          for HOST in $(echo "$METAL_HOSTS" | tr ',' ' '); do
            start_on_host "$HOST" > "${LOG_DIR}/${HOST}.log" 2>&1 &
            PIDS+=($!)
            HOSTS+=("$HOST")
          done

          FAILED=0
          for i in "${!PIDS[@]}"; do
            if ! wait "${PIDS[$i]}"; then
              FAILED=1
              echo "::error::Runner start failed on ${HOSTS[$i]}"
            fi
            echo "=== ${HOSTS[$i]} ==="
            cat "${LOG_DIR}/${HOSTS[$i]}.log"
          done
          rm -rf "$LOG_DIR"
          if [ "$FAILED" -ne 0 ]; then
            exit 1
          fi

  # Run CLI E2E tests - Phase 3: Runner tests (needs runner deployed)
  # Skip on push to main - runner tests are only needed for PRs
  cli-e2e-03-runner:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs:
      [
        prepare,
        cli-e2e-01-serial,
        deploy-web,
        deploy-runner-prepare,
        deploy-runner-start,
      ]
    if: |
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.prepare.outputs.job-ref != '' && (
        needs.prepare.outputs.web-changed == 'true' ||
        needs.prepare.outputs.cli-changed == 'true' ||
        needs.prepare.outputs.runner-changed == 'true' ||
        needs.prepare.outputs.crates-changed == 'true'
      )
    timeout-minutes: 8
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: recursive
      - uses: ./.github/actions/toolchain-init

      - name: Setup pnpm global directory
        run: |
          mkdir -p $HOME/.local/share/pnpm
          pnpm config set global-bin-dir $HOME/.local/share/pnpm
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

      - name: Build Sandbox Scripts
        run: cd turbo && pnpm turbo run build --filter=@vm0/sandbox-scripts

      - name: Build CLI
        run: cd turbo && pnpm --filter @vm0/cli build

      - name: Setup CLI globally
        run: cd turbo/apps/cli && pnpm link --global

      - name: Install GNU parallel for bats
        run: apt-get update && apt-get install -y parallel

      - name: Restore test token from cache
        uses: actions/cache/restore@v5
        with:
          path: ~/.vm0
          key: e2e-token-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-token-${{ github.run_id }}-
          fail-on-cache-miss: true

      - name: Start Cron Simulator
        run: |
          chmod +x ./e2e/scripts/cron-simulator.sh
          ./e2e/scripts/cron-simulator.sh "$VM0_API_URL" 60 &
          echo "CRON_SIMULATOR_PID=$!" >> $GITHUB_ENV
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Runner E2E Tests
        run: |
          PARALLEL=$(( HOST_COUNT * 5 ))
          echo "=== Running Runner E2E Tests (${PARALLEL} parallel across ${HOST_COUNT} hosts) ==="
          BATS_TEST_TIMEOUT=60 RUNNER_GROUP="vm0/development-${JOB_REF}" ./e2e/test/libs/bats/bin/bats -T -j "${PARALLEL}" --no-parallelize-within-files ./e2e/tests/03-experimental-runner/*.bats
          echo "✅ Runner tests passed"
        env:
          VM0_API_URL: ${{ needs.deploy-web.outputs.preview-url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
          USE_MOCK_CLAUDE: "true"
          ANTHROPIC_API_KEY: ${{ secrets.CI_ANTHROPIC_API_KEY }}
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          OFFICIAL_RUNNER_SECRET: ${{ secrets.OFFICIAL_RUNNER_SECRET }}
          HOST_COUNT: ${{ needs.deploy-runner-prepare.outputs.host-count }}

      - name: Stop Cron Simulator
        if: always()
        run: |
          if [ -n "$CRON_SIMULATOR_PID" ]; then
            kill "$CRON_SIMULATOR_PID" 2>/dev/null || true
            echo "Cron simulator stopped"
          fi

  # Stop runner service and clean up after cli-e2e-03-runner completes (or fails/times out)
  # Skip on push to main - runner deployment is only needed for PRs
  cleanup-runner:
    runs-on: ubuntu-latest
    needs: [prepare, deploy-runner-prepare, deploy-runner-start, cli-e2e-03-runner]
    if: |
      always() &&
      contains(github.event.pull_request.labels.*.name, 'needs-runner-pipeline') &&
      github.event_name != 'push' &&
      needs.deploy-runner-prepare.outputs.bin-dir != ''
    steps:
      # Read METAL_HOSTS from secret directly — GitHub Actions masks secret values in job outputs
      - name: Cleanup runner on all metal hosts
        env:
          METAL_USER: ${{ vars.AWS_METAL_RUNNER_USER }}
          METAL_HOSTS: ${{ secrets.AWS_METAL_RUNNER_HOSTS }}
          BIN_DIR: ${{ needs.deploy-runner-prepare.outputs.bin-dir }}
          RUNNER_DIR: ${{ needs.deploy-runner-prepare.outputs.runner-dir }}
          JOB_REF: ${{ needs.prepare.outputs.job-ref }}
          SSH_KEY: ${{ secrets.AWS_METAL_RUNNER_SSH_KEY }}
        run: |
          mkdir -p "$HOME/.ssh"
          echo "$SSH_KEY" > "$HOME/.ssh/runner.pem"
          chmod 600 "$HOME/.ssh/runner.pem"
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -i $HOME/.ssh/runner.pem"

          for HOST in $(echo "$METAL_HOSTS" | tr ',' ' '); do
            (
              REMOTE="${METAL_USER}@${HOST}"
              echo "Cleaning up ${JOB_REF} on ${HOST}"
              ssh $SSH_OPTS $REMOTE "${BIN_DIR}/runner service stop --name ${JOB_REF}" || true
              ssh $SSH_OPTS $REMOTE "rm -rf ${BIN_DIR} ${RUNNER_DIR}" || true
            ) &
          done
          wait

  # Build E2B templates (development account)
  # Uses repository-level E2B_API_KEY secret
  build-e2b-template:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/vm0-ai/vm0-toolchain:20260203
    needs: [prepare]
    # Build on PR or main push when E2B templates changed, skip release-please commits
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.e2b-changed == 'true'
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/toolchain-init

      - name: Build E2B templates
        working-directory: turbo
        env:
          E2B_API_KEY: ${{ secrets.E2B_API_KEY }}
        run: |
          pnpm e2b:build
          pnpm e2b:codex:build
          pnpm e2b:claude-code-github:build
          pnpm e2b:cli:build

      - name: Build summary
        run: echo "✅ E2B templates built successfully (development account)"

  # Docker build validation for application images (web, platform, sandbox)
  # Build only (no push) - publishing happens in release-please workflow
  docker-build-web:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      (needs.prepare.outputs.web-changed == 'true' || needs.prepare.outputs.docker-web-changed == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build web image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.web
          push: false
          tags: vm0:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

  docker-build-platform:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      (needs.prepare.outputs.platform-changed == 'true' || needs.prepare.outputs.docker-platform-changed == 'true')
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build platform image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.platform
          push: false
          tags: vm0-platform:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

  docker-build-sandbox:
    runs-on: ubuntu-latest
    needs: [prepare]
    if: |
      (github.event_name != 'push' || !startsWith(github.event.head_commit.message, 'chore: release')) &&
      needs.prepare.outputs.sandbox-changed == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build sandbox image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.sandbox
          push: false
          tags: vm0-sandbox:test
          cache-from: type=gha
          cache-to: type=gha,mode=max
